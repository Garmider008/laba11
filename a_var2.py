''''' Дан двійковий файл f, компоненти якого є цілими ненульовими числами,
причому кількість від'ємних чисел дорівнює кількості додатних, а загальне число
компонентів кратне 5. Використовуючи допоміжний файл h, переписати в порядку
проходження компоненти файлу f в файл g - три додатних, три від'ємних, три додатних,
три від'ємних і так далі.
Гармідер Анастасія 122В
'''''
from random import randint
import struct


def generateFile(filename='f'):
     """
     Что бы не писать много текста возле каждой строики расскажу в целом как работает программа. 
    Функция, которая генерирует файл F
    Кол-во компонентов - кол-во чисел, которые будем записывать.
    Из задания мы знаем, что их кол-во должно делиться на 5, потому мы добавляем единицы в цикле while пока components
    не будет делиться на 5.
    Так как кол-во чисел положительных и отрицательных должно быть равно, в таком случае кол-во компонентов
    должно быть делимо еще и на 2.

    listToWrite - лист, в который записываем числа.
    Цикл выполняеться только половину числа компонентов, потому что внутри него мы два раза записываем числа,
    одно положительное, и одно отрицательное.

    Далее сортируем список, чтобы негативные числа были слева, положительные справа.

    После мы записываем лист в файл, предварительно сделав строками каждые элемент листа,
     и превратив его в строку по окончанию.
    """
    components = randint(2, 100)
    while (components % 5 != 0) and (components % 2 != 0):
        components += 1
    with open(filename, 'wb') as f:
        listToWrite = []
        for i in range(components // 2):
            listToWrite.append(randint(-100, -1))
            listToWrite.append(randint(1, 100))
        packedInt = struct.pack(f'{len(listToWrite)}i', *listToWrite)
        f.write(packedInt)

"""
    Cчитываем строку из файла, разбиваем на лист, превращаем каждый элемент в число, приводим всё к листу,
    так как ф-ция map возвращает map-обьект, а не число.
    Создаем новый лист.
    Итераций в цикле - треть длинны листа из файла.
    Потому что с каждой итерацией мы записываем в новый лист три числа.
    Флаг - говорит каким образом сортировать изначальный список,чтобы с каждой итерацией у нас
    в начале списка были разные знаки, то есть сначала положительные, далее отрицательные,
    и так по кругу.
    Флаг меняеться каждый раз на противоположный, с помощью тернарного оператора.
    С каждой итерацией удаляем из изначального списка 3 элемента, чтобы их больше не добавлять.
    В итоге записываем результирующий список в файл.
    """
def writeToG(filename='g', filenameRead='f'):
    with open(filenameRead, 'rb') as f:
        listn = sorted([i[0] for i in struct.iter_unpack('i', f.read())])
    newList = []
    with open('g', 'wb') as g:
        for i in range(len(listn) // 3):
            flag = False if i % 2 != 0 else True
            listn = sorted(listn, reverse=flag)
            newList.extend(listn[0:3])
            listn = listn[3::]
        newList.extend(listn)
        print(newList)
        packedInt = struct.pack(f'{len(newList)}i', *newList)
        g.write(packedInt)


if name == 'main':
    # якщо скрипт запущений на пряму, тільки тоді буде виконаний код нижче
    generateFile()
    writeToG()
